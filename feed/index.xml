<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>LABULAC'S BLOG</title><link>http://blog.labulac.top/</link><description>labulac的blog站点</description><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://cdn.jsdelivr.net/gh/labulac/site-Wiki@gh-pages/android-chrome-512x512.png</url><title>LABULAC'S BLOG</title><link>http://blog.labulac.top/</link></image><language>zh-CN</language><lastBuildDate>Fri, 13 Mar 2020 12:34:10 +0806</lastBuildDate><pubDate>Fri, 13 Mar 2020 12:34:10 +0806</pubDate><item><title>Python 中的变量传递方式</title><link>http://blog.labulac.top/archives/variable-pass-paradim-in-python/</link><description>&lt;p&gt;之前一直没有仔细思考过这个问题，直到最近用到方才深入了解。其实并不复杂，和 C++ 如出一辙。&lt;/p&gt;
&lt;h2&gt;Python 中的变量&lt;/h2&gt;
&lt;p&gt;简而言之，Python 中的变量都是对&lt;strong&gt;实体的引用&lt;/strong&gt;，但并&lt;strong&gt;不是实体本身&lt;/strong&gt;；此外，Python 的函数传参仍然&lt;strong&gt;遵循按值传递&lt;/strong&gt;，结合这两点就能搞明白 Python 的传参行为。&lt;/p&gt;
&lt;p&gt;先抛开具体的编程语言，如果有以下伪代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a=1
a=2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多数语言会把这两行解释为：声明一个变量 a，在内存里分配空间，这个空间&lt;strong&gt;就叫 a&lt;/strong&gt;，里面存 1；然后把这个空间里的值更新成 2。&lt;/p&gt;
&lt;p&gt;但是 Python 中对变量（其实是对象）的处理有所不同。以上两行在 Python 中代表：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个对象（整数 1），放在内存里，再&lt;strong&gt;创建一个引用，这个引用叫做 a&lt;/strong&gt;，指向之前创建的对象&lt;/li&gt;
&lt;li&gt;又创建一个对象（整数 2），放在内存里，把 a 指向这个新的对象&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看到不同了吧？接下来讨论函数传参。&lt;/p&gt;
&lt;h2&gt;Python 中的传参&lt;/h2&gt;
&lt;p&gt;在 Python 中的函数传参是依照&lt;strong&gt;值传递&lt;/strong&gt;的；但由于 Python 中的变量都是引用，因此就有了以下这句有点绕的话：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Python passes references-to-objects by value (like Java), and everything in Python is an object.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看以下代码段&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1]
[1, 2]
[1, 2]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用 &lt;code&gt;func&lt;/code&gt; 并把 a 传入时，Python 在局部&lt;strong&gt;新建了一个局部的变量 a&lt;/strong&gt;，并把外部 a 的值赋值给了新的变量。由于 a 是引用，新的变量也是引用，都指向内存中的同一个列表对象，因此在函数内部对列表进行的操作也同样可以由外部的 a 观测到。&lt;/p&gt;
&lt;p&gt;然而，要注意两个陷阱：对引用进行 &lt;strong&gt;re-assign&lt;/strong&gt;；以及对 &lt;strong&gt;immutable 对象&lt;/strong&gt;的处理。&lt;/p&gt;
&lt;h2&gt;对引用 re-assign&lt;/h2&gt;
&lt;p&gt;修改以上代码为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;# 注意这里&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1]
['a']
[1]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么函数内对 a 的修改不能被外部的 a 观测到？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;a=['a']&lt;/code&gt; 这行代码并不是通过 a 修改 a 指向的 list，而是在内存中新建了一个列表对象 &lt;code&gt;['a']&lt;/code&gt;，并将函数内部的 a 指向了这个新的对象，并且此后的操作都针对这个新的列表对象；然而由于函数内部的 a 与外部的 a 是两个不同的变量，因此外部的 a 仍然指向之前的 list。这种操作称为 &lt;code&gt;re-assign&lt;/code&gt;，需要与 &lt;code&gt;append&lt;/code&gt; 这种针对对象本身的方法区别开。&lt;/p&gt;
&lt;h2&gt;immutable 对象的处理&lt;/h2&gt;
&lt;p&gt;如果不使用列表，而使用字符串：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;changed&amp;#39;&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;original&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;original
changed
original&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果理解了前文的要点，那么针对 immutable 对象的处理并不难懂。由于 str 对象是 immutable 的（不可变对象），因此函数内部不能通过 a 修改指向的字符串，&lt;code&gt;a='changed'&lt;/code&gt; 这行代码实际是在进行 re-assign，也就是新建了一个字符串对象 &lt;code&gt;'changed'&lt;/code&gt;，使函数内部的 a 指向这个新的对象。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;总而言之记住三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Python 中的变量是对象的引用，而不是对象本身&lt;/li&gt;
&lt;li&gt;Python 按值传参&lt;/li&gt;
&lt;li&gt;警惕对引用进行 re-assign 与通过引用修改对象的区别&lt;/li&gt;
&lt;/ol&gt;
</description><author>vector051545@gmail.com (熊猫小A)</author><guid isPermaLink="true">http://blog.labulac.top/archives/variable-pass-paradim-in-python/</guid><pubDate>Thu, 02 Jan 2020 15:20:00 +0806</pubDate></item><item><title>VS Code Pylint E1101 Module has no member 错误</title><link>http://blog.labulac.top/archives/vs-code-pylint-e1101-module-has-no-member/</link><description>&lt;p&gt;VS Code 出现类似这样的问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Pylint E1101 Module 'torch' has no 'from_numpy' member...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是 Pylint 的问题，三种方案都行：&lt;/p&gt;
&lt;h2&gt;行内禁用提示&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# pylint: disable=E1101&lt;/span&gt;
&lt;span class="n"&gt;tensor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;torch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from_numpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np_array&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# pylint: enable=E1101&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有点 ugly。&lt;/p&gt;
&lt;h2&gt;设置忽略提示&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;.pylintrc&lt;/code&gt; 中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[MASTER]
extension-pkg-whitelist=numpy,torch,cv,cv2

[TYPECHECK]
ignored-modules=numpy,torch,cv,cv2
ignored-classes=numpy,torch,cv,cv2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也不是很优雅。&lt;/p&gt;
&lt;h2&gt;将 Member 指定为 generated&lt;/h2&gt;
&lt;p&gt;VS Code 设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;"python.linting.pylintArgs": [
    "--errors-only",
    "--generated-members=numpy.* ,torch.* ,cv2.* , cv.*"
]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个还可以。&lt;/p&gt;
</description><author>vector051545@gmail.com (熊猫小A)</author><guid isPermaLink="true">http://blog.labulac.top/archives/vs-code-pylint-e1101-module-has-no-member/</guid><pubDate>Thu, 09 Jan 2020 09:28:00 +0806</pubDate></item><item><title>Linux 使用 WebDAV</title><link>http://blog.labulac.top/archives/using-webdav-on-linux/</link><description>&lt;p&gt;Centos &amp;amp; Fedora &amp;amp; RedHat&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum -y install davfs2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他的比如Ubuntu之类的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get -y install davfs2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完davfs2之后执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -i 's/# use_locks       1/use_locks       0/g' /etc/davfs2/davfs2.conf
echo "你的WebDAV地址 用户名 密码" &amp;gt;&amp;gt; /etc/davfs2/secrets #保存用户名密码，以后可以直接免密码挂载
mount.davfs 你的WebDAV地址 你想要挂载到的目录&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可成功挂载&lt;/p&gt;
&lt;p&gt;取消挂载：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;umount.davfs 挂载目录
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意1：挂载目录必须提前创建好！
注意2：如果你不执行第二句保存用户名密码，那么你以后挂载的时候都会要求输入用户名密码！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;挂载时若提示 &lt;code&gt;the server does not support WebDAV&lt;/code&gt;，可配置忽略 WebDAV 头：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vi /etc/davfs2/davfs2.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;搜索并修改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ignore_dav_header 1&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;来自：&lt;a href="https://moe.best/linux-memo/mount-webdav.html"&gt;如何在各个平台下挂载WebDAV&lt;/a&gt;。&lt;/p&gt;
</description><author>vector051545@gmail.com (熊猫小A)</author><guid isPermaLink="true">http://blog.labulac.top/archives/using-webdav-on-linux/</guid><pubDate>Mon, 10 Feb 2020 19:58:00 +0806</pubDate></item><item><title>ffmpeg 常用指令</title><link>http://blog.labulac.top/archives/ffmpeg-cheat-sheet/</link><description>&lt;p&gt;&lt;strong&gt;视频格式转换：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ffmpeg -i input.flv output.mp4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;视频截取：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ffmpeg -ss &lt;span class="m"&gt;00&lt;/span&gt;:00:00 -t &lt;span class="m"&gt;00&lt;/span&gt;:00:30 -i input.mp4 -vcodec copy -acodec copy output.mp4
&lt;span class="c1"&gt;# -ss 指定从什么时间开始&lt;/span&gt;
&lt;span class="c1"&gt;# -t 指定需要截取多长时间&lt;/span&gt;
&lt;span class="c1"&gt;# -i 指定输入文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;视频去除音频：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ffmpeg -i input.mp4 -map &lt;span class="m"&gt;0&lt;/span&gt;:0 -vcodec copy output.mp4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;视频提取音频：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ffmpeg -i input.mp4 -f mp3 -vn output.mp3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;视频剪裁：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ffmpeg -i input.mp4 -filter:v &lt;span class="s2"&gt;&amp;quot;crop=out_w:out_h:x:y&amp;quot;&lt;/span&gt; output.mp4
&lt;span class="c1"&gt;# out_w: 输出宽度&lt;/span&gt;
&lt;span class="c1"&gt;# out_h: 输出高度&lt;/span&gt;
&lt;span class="c1"&gt;# (x, y): 左上角坐标，横向为x轴&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;视频拼接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先准备文本文件 filelist.txt，写入要合并的文件名：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;file input1.mp4
file input2.mp4
file input3.mp4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ffmpeg -f concat -i filelist.txt -c copy output.mp4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意尺寸与格式等。&lt;/p&gt;
</description><author>vector051545@gmail.com (熊猫小A)</author><guid isPermaLink="true">http://blog.labulac.top/archives/ffmpeg-cheat-sheet/</guid><pubDate>Thu, 13 Feb 2020 10:38:00 +0806</pubDate></item><item><title>使用 openssl 生成自签名证书</title><link>http://blog.labulac.top/archives/generate-self-signed-cert-with-openssl/</link><description>&lt;p&gt;通过 openssl 生成私钥 server.key：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;openssl genrsa -out server.key &lt;span class="m"&gt;1024&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据私钥生成证书申请文件 csr：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;openssl req -new -key server.key -out server.csr
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据提示输入各项参数。Common Name 这一项可以填通配符域名。&lt;/p&gt;
&lt;p&gt;使用私钥签名生成证书 server.crt：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;openssl x509 -req -in server.csr -out server.crt -signkey server.key -days &lt;span class="m"&gt;3650&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有效期 3650 天。自己调试开发足够了。&lt;/p&gt;
</description><author>vector051545@gmail.com (熊猫小A)</author><guid isPermaLink="true">http://blog.labulac.top/archives/generate-self-signed-cert-with-openssl/</guid><pubDate>Sun, 01 Mar 2020 13:15:00 +0806</pubDate></item><item><title>原生 Telegram 解锁</title><link>http://blog.labulac.top/archives/telegram/</link><description>&lt;h3&gt;介绍&lt;/h3&gt;
&lt;p&gt;&lt;img src="https://cdn.jsdelivr.net/gh/labulac/pic@master/uPic/CRRSNC.png" alt="" style="zoom:33%;" /&gt;&lt;/p&gt;
&lt;h3&gt;准备&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原生 TG （版本 ≥ 5.1.3  iOS 商店：&lt;a href="https://apps.apple.com/cn/app/telegram-messenger/id686449807"&gt;点击下载&lt;/a&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Telegram Win Desktop （版本 ≥ 1.9.3  云盘：&lt;a href="https://www.lanzous.com/b0cvwkj4j"&gt;点击下载&lt;/a&gt;  官网：&lt;a href="https://desktop.telegram.org"&gt;https://desktop.telegram.org&lt;/a&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;官网Web：&lt;a href="http://web.telegram.org"&gt;http://web.telegram.org&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;解锁&lt;strong&gt;（两种方法）&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Desktop 客户端：&lt;strong&gt;Settings→Privacy and Security→Sensutive content→Disable filtering&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Web：&lt;strong&gt;Settings→Show Sensitive Content&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;重启手机客户端&lt;/li&gt;
&lt;/ol&gt;
</description><author>vector051545@gmail.com (labulac)</author><guid isPermaLink="true">http://blog.labulac.top/archives/telegram/</guid><pubDate>Thu, 05 Mar 2020 20:18:00 +0806</pubDate></item><item><title>“您不能使用以点“.”开头的名称，由于系统预留的解决方法</title><link>http://blog.labulac.top/archives/显示隐藏的系统文件/</link><description>&lt;h3&gt;描述&lt;/h3&gt;
&lt;p&gt;遇到这样的问题：&lt;/p&gt;
&lt;p&gt;提示：“您不能使用以点“.”开头的名称，因为这些名称已被系统预留。请选取其他名称。”&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="836" data-height="294" src="https://cdn.jsdelivr.net/gh/labulac/pic@master/uPic/NgQ0yL.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;解决&lt;/h3&gt;
&lt;p&gt;文件最前面带上.就会变成隐藏文件，系统默认不显示隐藏文件，所以你必须开启显示隐藏文件才能把文件命名为隐藏文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;显示隐藏文件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开『终端』这个程序，输入以下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;defaults write com.apple.finder AppleShowAllFiles -boolean &lt;span class="nb"&gt;true&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; killall Finder
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;回车执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隐藏隐藏文件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开『终端』这个程序，输入以下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;defaults write com.apple.finder AppleShowAllFiles FALSE &lt;span class="p"&gt;;&lt;/span&gt; killall Finder
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;回车执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以上&lt;/strong&gt;&lt;/p&gt;
</description><author>vector051545@gmail.com (labulac)</author><guid isPermaLink="true">http://blog.labulac.top/archives/显示隐藏的系统文件/</guid><pubDate>Sat, 07 Mar 2020 11:54:00 +0806</pubDate></item><item><title>MacOS 允许任何安装来源</title><link>http://blog.labulac.top/archives/允许任何安装来源/</link><description>&lt;h3&gt;问题来源&lt;/h3&gt;
&lt;p&gt;Mac 升级系统后发现有些非官方渠道的软件，无法安装&lt;/p&gt;
&lt;p&gt;同时发现 &lt;strong&gt;安全性与隐私&lt;/strong&gt; 的 &lt;strong&gt;允许从以下位置下载的应用：&lt;/strong&gt; 中的&lt;strong&gt;任何来源&lt;/strong&gt;选项也不见了...&lt;/p&gt;
&lt;h3&gt;解决办法&lt;/h3&gt;
&lt;p&gt;在终端中输入以下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo spctl --master-disable
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在设置里又可以看到&lt;u&gt;允许未知来源&lt;/u&gt;又出现了&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1336" data-height="1146" src="https://cdn.jsdelivr.net/gh/labulac/pic@master/uPic/aQdxf1.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;点击那个小黄锁，输入密码，选中。&lt;/p&gt;
&lt;p&gt;然后安装你想要安装的软件 ！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以上&lt;/strong&gt;&lt;/p&gt;
</description><author>vector051545@gmail.com (labulac)</author><guid isPermaLink="true">http://blog.labulac.top/archives/允许任何安装来源/</guid><pubDate>Sat, 07 Mar 2020 15:44:00 +0806</pubDate></item><item><title>Python pip3 运行出错：Missing dependencies for SOCK</title><link>http://blog.labulac.top/archives/pip安装报错 Could not install packages due to an EnvironmentError/</link><description>&lt;h3&gt;问题&lt;/h3&gt;
&lt;p&gt;pip安装报错Could not install packages due to an EnvironmentError: Missing dependencies for SOCK&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="-1" data-height="-1" src="https://gitee.com/labulac/pic/raw/master/uPic/Wnaa3a.png" alt="Wnaa3a" /&gt;&lt;figcaption&gt;Wnaa3a&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;解决方法&lt;/h3&gt;
&lt;p&gt;终端输入以下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;unset&lt;/span&gt; all_proxy &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nb"&gt;unset&lt;/span&gt; ALL_PROXY
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;以上&lt;/strong&gt;&lt;/p&gt;
</description><author>vector051545@gmail.com (labulac)</author><guid isPermaLink="true">http://blog.labulac.top/archives/pip安装报错 Could not install packages due to an EnvironmentError/</guid><pubDate>Mon, 09 Mar 2020 10:48:00 +0806</pubDate></item><item><title>MacOS 删除灰色的ABC输入法</title><link>http://blog.labulac.top/archives/ABC/</link><description>&lt;h3&gt;问题来源&lt;/h3&gt;
&lt;p&gt;总是很烦ABC输入法，明明不怎么需要&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="-1" data-height="-1" src="https://gitee.com/labulac/pic/raw/master/uPic/GPH9jG.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;又是灰色的，如何删除呢？&lt;/p&gt;
&lt;h3&gt;解决&lt;/h3&gt;
&lt;p&gt;1.首先要关闭系统的完整性保护，即关闭SIP，方法是在重启电脑时按住 command + R 进入恢复模式，然后选择实用工具中的 终端，输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;csrutil disable
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;回车，显示成功关闭SIP，之后重启电脑。&lt;/p&gt;
&lt;p&gt;2.之后打开终端，在命令行输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo open -a /Applications/Xcode.app ~/Library/Preferences/com.apple.HIToolbox.plist
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;回车之后输入密码确认，之后便用Xcode打开了这个配置文件。&lt;/p&gt;
&lt;p&gt;另：&lt;/p&gt;
&lt;p&gt;若是使用PlistEdit Pro则输入这个：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo open -a /Applications/PlistEdit&lt;span class="se"&gt;\ &lt;/span&gt;Pro.app ~/Library/Preferences/com.apple.HIToolbox.plist
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样输入密码确认，之后便用PlistEdit Pro打开了这个配置文件。&lt;/p&gt;
&lt;p&gt;3.删除红框键值下的子键中带有ABC字样的整个键值&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="-1" data-height="-1" src="https://gitee.com/labulac/pic/raw/master/uPic/A0lUBr.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;4.删除之后点击保存，如果不能直接保存则可以先将修改的后的文件另存为到桌面上，然后再将文件复制到 ~/Library/Preferences 此处，至此已经修改完成。&lt;/p&gt;
&lt;p&gt;5.下面是将系统完整性保护打开：&lt;/p&gt;
&lt;p&gt;重启，进入恢复模式，然后输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;csrutil &lt;span class="nb"&gt;enable&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打开系统完整性保护。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以上&lt;/strong&gt;&lt;/p&gt;
</description><author>vector051545@gmail.com (labulac)</author><guid isPermaLink="true">http://blog.labulac.top/archives/ABC/</guid><pubDate>Wed, 11 Mar 2020 09:44:00 +0806</pubDate></item></channel></rss>
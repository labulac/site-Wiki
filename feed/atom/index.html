<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><id>http://blog.labulac.top/</id><title>LABULAC'S BLOG</title><updated>2020-03-07T13:12:05.645248+08:06</updated><author><name>D0raemon</name><email>vector051545@gmail.com</email></author><link href="http://blog.labulac.top/" rel="alternate"/><generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator><logo>https://cdn.jsdelivr.net/gh/labulac/site-Wiki@gh-pages/android-chrome-512x512.png</logo><subtitle>labulac的blog站点</subtitle><entry><id>http://blog.labulac.top/archives/Marching Cubes 算法提取等值面/</id><title>Marching Cubes 算法提取等值面</title><updated>2020-03-07T13:12:05.645535+00:00</updated><author><name>熊猫小A</name><email>vector051545@gmail.com</email><uri>https://github.com/labulac</uri></author><content>&lt;p&gt;不失一般性，以抽取 0 等值面举例，假设面一侧为正值，另一侧为负值。则 Marching Cubes 算法总体上通过两个步骤建立这个等值面的 mesh 模型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;估计每个 cell 内的三角面片数量与连接方式（拓扑结构）&lt;/li&gt;
&lt;li&gt;计算确定个面片的每个顶点的具体位置&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;&lt;p&gt;这里的 cell 区别于 voxel。voxel 可认为是对三维场的采样与离散，采样点位于 voxel 中心，这些采样点作为顶点则构成了 cell。即 cell 是以采样点为顶点的三维网格。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体而言，对每一个 cell，首先确定这个 cell 内部面片的拓扑结构。即通过判断这个 cell 各顶点的符号来判断 cell 哪部分处于面内。当相邻两顶点符号改变时，表名这条边穿过了面，因此该边上必定有一个面片顶点（vertice）。这样，每个顶点都有两种情况：面内、面外，总共就有2^8 = 256 中情况，这些情况可归类为 15 中基本情况：&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="581" data-height="304" src="https://cdn.jsdelivr.net/gh/labulac/site-Wiki@gh-pages/archives/assets/cf8912ad3cd96f93f718ee2aa3864674.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;图中黄色背景的代表 cell 内只有一个连续面片的情况；其它则代表有多个面片的情况。&lt;/p&gt;
&lt;p&gt;得到拓扑结构后，对每条包含 vertice 的边进行线性插值，找到 0 值的位置，即可作为 vertice 的坐标，由此完成 mesh 提取。&lt;/p&gt;
</content><link href="http://blog.labulac.top/archives/Marching Cubes 算法提取等值面/" rel="alternate"/><published>2019-11-01T16:06:00+08:06</published></entry><entry><id>http://blog.labulac.top/archives/命令行查看 SSL 证书过期时间/</id><title>命令行查看 SSL 证书过期时间</title><updated>2020-03-07T13:12:05.645512+00:00</updated><author><name>熊猫小A</name><email>vector051545@gmail.com</email><uri>https://github.com/labulac</uri></author><content>&lt;p&gt;命令行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl x509 -in server.crt -noout -dates&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;notBefore=Dec 24 08:04:53 2019 GMT
notAfter=Mar 23 08:04:53 2020 GMT&lt;/code&gt;&lt;/pre&gt;
</content><link href="http://blog.labulac.top/archives/命令行查看 SSL 证书过期时间/" rel="alternate"/><published>2019-12-26T19:19:00+08:06</published></entry><entry><id>http://blog.labulac.top/archives/variable-pass-paradim-in-python/</id><title>Python 中的变量传递方式</title><updated>2020-03-07T13:12:05.645490+00:00</updated><author><name>熊猫小A</name><email>vector051545@gmail.com</email><uri>https://github.com/labulac</uri></author><content>&lt;p&gt;之前一直没有仔细思考过这个问题，直到最近用到方才深入了解。其实并不复杂，和 C++ 如出一辙。&lt;/p&gt;
&lt;h2&gt;Python 中的变量&lt;/h2&gt;
&lt;p&gt;简而言之，Python 中的变量都是对&lt;strong&gt;实体的引用&lt;/strong&gt;，但并&lt;strong&gt;不是实体本身&lt;/strong&gt;；此外，Python 的函数传参仍然&lt;strong&gt;遵循按值传递&lt;/strong&gt;，结合这两点就能搞明白 Python 的传参行为。&lt;/p&gt;
&lt;p&gt;先抛开具体的编程语言，如果有以下伪代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a=1
a=2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多数语言会把这两行解释为：声明一个变量 a，在内存里分配空间，这个空间&lt;strong&gt;就叫 a&lt;/strong&gt;，里面存 1；然后把这个空间里的值更新成 2。&lt;/p&gt;
&lt;p&gt;但是 Python 中对变量（其实是对象）的处理有所不同。以上两行在 Python 中代表：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个对象（整数 1），放在内存里，再&lt;strong&gt;创建一个引用，这个引用叫做 a&lt;/strong&gt;，指向之前创建的对象&lt;/li&gt;
&lt;li&gt;又创建一个对象（整数 2），放在内存里，把 a 指向这个新的对象&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看到不同了吧？接下来讨论函数传参。&lt;/p&gt;
&lt;h2&gt;Python 中的传参&lt;/h2&gt;
&lt;p&gt;在 Python 中的函数传参是依照&lt;strong&gt;值传递&lt;/strong&gt;的；但由于 Python 中的变量都是引用，因此就有了以下这句有点绕的话：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Python passes references-to-objects by value (like Java), and everything in Python is an object.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看以下代码段&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1]
[1, 2]
[1, 2]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用 &lt;code&gt;func&lt;/code&gt; 并把 a 传入时，Python 在局部&lt;strong&gt;新建了一个局部的变量 a&lt;/strong&gt;，并把外部 a 的值赋值给了新的变量。由于 a 是引用，新的变量也是引用，都指向内存中的同一个列表对象，因此在函数内部对列表进行的操作也同样可以由外部的 a 观测到。&lt;/p&gt;
&lt;p&gt;然而，要注意两个陷阱：对引用进行 &lt;strong&gt;re-assign&lt;/strong&gt;；以及对 &lt;strong&gt;immutable 对象&lt;/strong&gt;的处理。&lt;/p&gt;
&lt;h2&gt;对引用 re-assign&lt;/h2&gt;
&lt;p&gt;修改以上代码为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;# 注意这里&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1]
['a']
[1]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么函数内对 a 的修改不能被外部的 a 观测到？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;a=['a']&lt;/code&gt; 这行代码并不是通过 a 修改 a 指向的 list，而是在内存中新建了一个列表对象 &lt;code&gt;['a']&lt;/code&gt;，并将函数内部的 a 指向了这个新的对象，并且此后的操作都针对这个新的列表对象；然而由于函数内部的 a 与外部的 a 是两个不同的变量，因此外部的 a 仍然指向之前的 list。这种操作称为 &lt;code&gt;re-assign&lt;/code&gt;，需要与 &lt;code&gt;append&lt;/code&gt; 这种针对对象本身的方法区别开。&lt;/p&gt;
&lt;h2&gt;immutable 对象的处理&lt;/h2&gt;
&lt;p&gt;如果不使用列表，而使用字符串：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;changed&amp;#39;&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;original&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;original
changed
original&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果理解了前文的要点，那么针对 immutable 对象的处理并不难懂。由于 str 对象是 immutable 的（不可变对象），因此函数内部不能通过 a 修改指向的字符串，&lt;code&gt;a='changed'&lt;/code&gt; 这行代码实际是在进行 re-assign，也就是新建了一个字符串对象 &lt;code&gt;'changed'&lt;/code&gt;，使函数内部的 a 指向这个新的对象。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;总而言之记住三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Python 中的变量是对象的引用，而不是对象本身&lt;/li&gt;
&lt;li&gt;Python 按值传参&lt;/li&gt;
&lt;li&gt;警惕对引用进行 re-assign 与通过引用修改对象的区别&lt;/li&gt;
&lt;/ol&gt;
</content><link href="http://blog.labulac.top/archives/variable-pass-paradim-in-python/" rel="alternate"/><published>2020-01-02T15:20:00+08:06</published></entry><entry><id>http://blog.labulac.top/archives/vs-code-pylint-e1101-module-has-no-member/</id><title>VS Code Pylint E1101 Module has no member 错误</title><updated>2020-03-07T13:12:05.645468+00:00</updated><author><name>熊猫小A</name><email>vector051545@gmail.com</email><uri>https://github.com/labulac</uri></author><content>&lt;p&gt;VS Code 出现类似这样的问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Pylint E1101 Module 'torch' has no 'from_numpy' member...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是 Pylint 的问题，三种方案都行：&lt;/p&gt;
&lt;h2&gt;行内禁用提示&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# pylint: disable=E1101&lt;/span&gt;
&lt;span class="n"&gt;tensor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;torch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from_numpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np_array&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# pylint: enable=E1101&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有点 ugly。&lt;/p&gt;
&lt;h2&gt;设置忽略提示&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;.pylintrc&lt;/code&gt; 中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[MASTER]
extension-pkg-whitelist=numpy,torch,cv,cv2

[TYPECHECK]
ignored-modules=numpy,torch,cv,cv2
ignored-classes=numpy,torch,cv,cv2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也不是很优雅。&lt;/p&gt;
&lt;h2&gt;将 Member 指定为 generated&lt;/h2&gt;
&lt;p&gt;VS Code 设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;"python.linting.pylintArgs": [
    "--errors-only",
    "--generated-members=numpy.* ,torch.* ,cv2.* , cv.*"
]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个还可以。&lt;/p&gt;
</content><link href="http://blog.labulac.top/archives/vs-code-pylint-e1101-module-has-no-member/" rel="alternate"/><published>2020-01-09T09:28:00+08:06</published></entry><entry><id>http://blog.labulac.top/archives/using-webdav-on-linux/</id><title>Linux 使用 WebDAV</title><updated>2020-03-07T13:12:05.645446+00:00</updated><author><name>熊猫小A</name><email>vector051545@gmail.com</email><uri>https://github.com/labulac</uri></author><content>&lt;p&gt;Centos &amp;amp; Fedora &amp;amp; RedHat&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum -y install davfs2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他的比如Ubuntu之类的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get -y install davfs2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完davfs2之后执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -i 's/# use_locks       1/use_locks       0/g' /etc/davfs2/davfs2.conf
echo "你的WebDAV地址 用户名 密码" &amp;gt;&amp;gt; /etc/davfs2/secrets #保存用户名密码，以后可以直接免密码挂载
mount.davfs 你的WebDAV地址 你想要挂载到的目录&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可成功挂载&lt;/p&gt;
&lt;p&gt;取消挂载：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;umount.davfs 挂载目录
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意1：挂载目录必须提前创建好！
注意2：如果你不执行第二句保存用户名密码，那么你以后挂载的时候都会要求输入用户名密码！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;挂载时若提示 &lt;code&gt;the server does not support WebDAV&lt;/code&gt;，可配置忽略 WebDAV 头：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vi /etc/davfs2/davfs2.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;搜索并修改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ignore_dav_header 1&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;来自：&lt;a href="https://moe.best/linux-memo/mount-webdav.html"&gt;如何在各个平台下挂载WebDAV&lt;/a&gt;。&lt;/p&gt;
</content><link href="http://blog.labulac.top/archives/using-webdav-on-linux/" rel="alternate"/><published>2020-02-10T19:58:00+08:06</published></entry><entry><id>http://blog.labulac.top/archives/ffmpeg-cheat-sheet/</id><title>ffmpeg 常用指令</title><updated>2020-03-07T13:12:05.645423+00:00</updated><author><name>熊猫小A</name><email>vector051545@gmail.com</email><uri>https://github.com/labulac</uri></author><content>&lt;p&gt;&lt;strong&gt;视频格式转换：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ffmpeg -i input.flv output.mp4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;视频截取：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ffmpeg -ss &lt;span class="m"&gt;00&lt;/span&gt;:00:00 -t &lt;span class="m"&gt;00&lt;/span&gt;:00:30 -i input.mp4 -vcodec copy -acodec copy output.mp4
&lt;span class="c1"&gt;# -ss 指定从什么时间开始&lt;/span&gt;
&lt;span class="c1"&gt;# -t 指定需要截取多长时间&lt;/span&gt;
&lt;span class="c1"&gt;# -i 指定输入文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;视频去除音频：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ffmpeg -i input.mp4 -map &lt;span class="m"&gt;0&lt;/span&gt;:0 -vcodec copy output.mp4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;视频提取音频：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ffmpeg -i input.mp4 -f mp3 -vn output.mp3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;视频剪裁：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ffmpeg -i input.mp4 -filter:v &lt;span class="s2"&gt;&amp;quot;crop=out_w:out_h:x:y&amp;quot;&lt;/span&gt; output.mp4
&lt;span class="c1"&gt;# out_w: 输出宽度&lt;/span&gt;
&lt;span class="c1"&gt;# out_h: 输出高度&lt;/span&gt;
&lt;span class="c1"&gt;# (x, y): 左上角坐标，横向为x轴&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;视频拼接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先准备文本文件 filelist.txt，写入要合并的文件名：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;file input1.mp4
file input2.mp4
file input3.mp4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ffmpeg -f concat -i filelist.txt -c copy output.mp4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意尺寸与格式等。&lt;/p&gt;
</content><link href="http://blog.labulac.top/archives/ffmpeg-cheat-sheet/" rel="alternate"/><published>2020-02-13T10:38:00+08:06</published></entry><entry><id>http://blog.labulac.top/archives/generate-self-signed-cert-with-openssl/</id><title>使用 openssl 生成自签名证书</title><updated>2020-03-07T13:12:05.645399+00:00</updated><author><name>熊猫小A</name><email>vector051545@gmail.com</email><uri>https://github.com/labulac</uri></author><content>&lt;p&gt;通过 openssl 生成私钥 server.key：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;openssl genrsa -out server.key &lt;span class="m"&gt;1024&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据私钥生成证书申请文件 csr：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;openssl req -new -key server.key -out server.csr
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据提示输入各项参数。Common Name 这一项可以填通配符域名。&lt;/p&gt;
&lt;p&gt;使用私钥签名生成证书 server.crt：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;openssl x509 -req -in server.csr -out server.crt -signkey server.key -days &lt;span class="m"&gt;3650&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有效期 3650 天。自己调试开发足够了。&lt;/p&gt;
</content><link href="http://blog.labulac.top/archives/generate-self-signed-cert-with-openssl/" rel="alternate"/><published>2020-03-01T13:15:00+08:06</published></entry><entry><id>http://blog.labulac.top/archives/telegram/</id><title>原生 Telegram 解锁</title><updated>2020-03-07T13:12:05.645374+00:00</updated><author><name>labulac</name><email>vector051545@gmail.com</email><uri>https://github.com/labulac</uri></author><content>&lt;h3&gt;介绍&lt;/h3&gt;
&lt;p&gt;&lt;img src="https://cdn.jsdelivr.net/gh/labulac/pic@master/uPic/CRRSNC.png" alt="" style="zoom:33%;" /&gt;&lt;/p&gt;
&lt;h3&gt;准备&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原生 TG （版本 ≥ 5.1.3  iOS 商店：&lt;a href="https://apps.apple.com/cn/app/telegram-messenger/id686449807"&gt;点击下载&lt;/a&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Telegram Win Desktop （版本 ≥ 1.9.3  云盘：&lt;a href="https://www.lanzous.com/b0cvwkj4j"&gt;点击下载&lt;/a&gt;  官网：&lt;a href="https://desktop.telegram.org"&gt;https://desktop.telegram.org&lt;/a&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;官网Web：&lt;a href="http://web.telegram.org"&gt;http://web.telegram.org&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;解锁&lt;strong&gt;（两种方法）&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Desktop 客户端：&lt;strong&gt;Settings→Privacy and Security→Sensutive content→Disable filtering&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Web：&lt;strong&gt;Settings→Show Sensitive Content&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;重启手机客户端&lt;/li&gt;
&lt;/ol&gt;
</content><link href="http://blog.labulac.top/archives/telegram/" rel="alternate"/><published>2020-03-05T20:18:00+08:06</published></entry><entry><id>http://blog.labulac.top/archives/显示隐藏的系统文件/</id><title>“您不能使用以点“.”开头的名称，由于系统预留的解决方法</title><updated>2020-03-07T13:12:05.645347+00:00</updated><author><name>labulac</name><email>vector051545@gmail.com</email><uri>https://github.com/labulac</uri></author><content>&lt;h3&gt;描述&lt;/h3&gt;
&lt;p&gt;遇到这样的问题：&lt;/p&gt;
&lt;p&gt;提示：“您不能使用以点“.”开头的名称，因为这些名称已被系统预留。请选取其他名称。”&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="836" data-height="294" src="https://cdn.jsdelivr.net/gh/labulac/pic@master/uPic/NgQ0yL.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;解决&lt;/h3&gt;
&lt;p&gt;文件最前面带上.就会变成隐藏文件，系统默认不显示隐藏文件，所以你必须开启显示隐藏文件才能把文件命名为隐藏文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;显示隐藏文件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开『终端』这个程序，输入以下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;defaults write com.apple.finder AppleShowAllFiles -boolean &lt;span class="nb"&gt;true&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; killall Finder
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;回车执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隐藏隐藏文件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开『终端』这个程序，输入以下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;defaults write com.apple.finder AppleShowAllFiles FALSE &lt;span class="p"&gt;;&lt;/span&gt; killall Finder
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;回车执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以上&lt;/strong&gt;&lt;/p&gt;
</content><link href="http://blog.labulac.top/archives/显示隐藏的系统文件/" rel="alternate"/><published>2020-03-07T11:54:00+08:06</published></entry><entry><id>http://blog.labulac.top/archives/允许任何安装来源/</id><title>MacOS 允许任何安装来源</title><updated>2020-03-07T13:12:05.645298+00:00</updated><author><name>labulac</name><email>vector051545@gmail.com</email><uri>https://github.com/labulac</uri></author><content>&lt;h3&gt;问题来源&lt;/h3&gt;
&lt;p&gt;Mac 升级系统后发现有些非官方渠道的软件，无法安装&lt;/p&gt;
&lt;p&gt;同时发现 &lt;strong&gt;安全性与隐私&lt;/strong&gt; 的 &lt;strong&gt;允许从以下位置下载的应用：&lt;/strong&gt; 中的&lt;strong&gt;任何来源&lt;/strong&gt;选项也不见了...&lt;/p&gt;
&lt;h3&gt;解决办法&lt;/h3&gt;
&lt;p&gt;在终端中输入以下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo spctl --master-disable
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在设置里又可以看到&lt;u&gt;允许未知来源&lt;/u&gt;又出现了&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1336" data-height="1146" src="https://cdn.jsdelivr.net/gh/labulac/pic@master/uPic/aQdxf1.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;点击那个小黄锁，输入密码，选中。&lt;/p&gt;
&lt;p&gt;然后安装你想要安装的软件 ！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以上&lt;/strong&gt;&lt;/p&gt;
</content><link href="http://blog.labulac.top/archives/允许任何安装来源/" rel="alternate"/><published>2020-03-07T15:44:00+08:06</published></entry></feed>